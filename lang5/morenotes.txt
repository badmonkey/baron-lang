Name(param1, param2, fun() -> ... end)
==

Name(param1, param2) do (x, y) -> ...
end

Name param1, param2 do (x, y) -> ...
end


select = [red -> "red"
         |blue -> "blue"
         |green -> "green]
select(x)

foo = [[(a, 0) -> a
       |(a, 1) -> a + 1
       |(a, 2) -> a * 2
       |(a, _) -> error]]

foo(a, 0) -> a
foo(a, 1) -> a + 1
foo(a, 2) -> a * 2
foo(a, _) -> error


reduce(0, list, foo/2)

reduce 0, list do
    (a, 0) -> a
    (a, 1) -> a + 1
end


(int, int, int) -> int
(int, int) -> (int -> int)
(int) -> (int -> (int -> int))
[x -> [y -> [z -> x + y + z]]]


try
    ...
catch
    pattern -> expression
    ...
after
    ...


try
    pattern <- expression
	expression
    pattern <- expression
	expression
	expression
    pattern <- expression
    ...
catch
	pattern -> expression
	pattern -> expression

end


with context [as v] EXPR
with context [as v] -> EXPR
with context [as v] begin ... end
with context [as v] do ... end
with context [as v] ... end


try
   context._enter_()
   ...
except
   ...
after
   context._exit__()

with file.lock()
    file.write()
end


let x = expr in expr



inheritance
+ share interface
+ share behaviour? - using inheritance instead of composition?
+ share state?


= Inheritance for interfaces =
interface base
    // not allowed state

    @public
    def method()
        // helpers that eventually call abstract methods (since they have no state to work with)

    @private
    def method_priv()
        // helper functions that can only be called by methods here or implementation of abstract methods in derived classes

    @abstract
    def method_abs()
end


class person implements base
    state: type

    @private
    def method2()
        // methods needs to be private because isn't part of interface

    def method_abs()
        // implementation of abstract methods that can operate on state

    // can't define any more abstract methods because we have state
    // all abstract methods need to be implemented
end

interface moreinterface extends base
    // still no state

    @public
    def method2()
        // new helper. has access to helpers/abstracts in base (not an implementation of abstracts)

    @abstract
    def methods2_abs()
        // an addition to the interface
end


can only inherit from class with abstract methods
class with unbound abstract methods can't have state


= inherit behaviour/state =

class point
    state: types

    @public
    def method():
        pass

    @private
    def priv_method():
        pass
end

class rect extends point
    morestate: type

    def more_methods()
        // addition methods, can't override methods(?)
end


= mixin them(?) =

class rect extends point implements area
end
